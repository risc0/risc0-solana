/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/web3.js';
import {
  type ParsedAcceptOwnershipInstruction,
  type ParsedAddVerifierInstruction,
  type ParsedCancelTransferInstruction,
  type ParsedEmergencyStopInstruction,
  type ParsedEmergencyStopWithProofInstruction,
  type ParsedInitializeInstruction,
  type ParsedRenounceOwnershipInstruction,
  type ParsedTransferOwnershipInstruction,
  type ParsedVerifyInstruction,
} from '../instructions';

export const VERIFIER_ROUTER_PROGRAM_ADDRESS =
  '8U8NcScoHfKhbJCCUCM4ckmynCbhFM9Mo2xLVgrbosfh' as Address<'8U8NcScoHfKhbJCCUCM4ckmynCbhFM9Mo2xLVgrbosfh'>;

export enum VerifierRouterAccount {
  VerifierEntry,
  VerifierRouter,
}

export function identifyVerifierRouterAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): VerifierRouterAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([102, 247, 148, 158, 33, 153, 100, 93])
      ),
      0
    )
  ) {
    return VerifierRouterAccount.VerifierEntry;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([188, 46, 30, 54, 25, 63, 197, 26])
      ),
      0
    )
  ) {
    return VerifierRouterAccount.VerifierRouter;
  }
  throw new Error(
    'The provided account could not be identified as a verifierRouter account.'
  );
}

export enum VerifierRouterInstruction {
  AcceptOwnership,
  AddVerifier,
  CancelTransfer,
  EmergencyStop,
  EmergencyStopWithProof,
  Initialize,
  RenounceOwnership,
  TransferOwnership,
  Verify,
}

export function identifyVerifierRouterInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): VerifierRouterInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([172, 23, 43, 13, 238, 213, 85, 150])
      ),
      0
    )
  ) {
    return VerifierRouterInstruction.AcceptOwnership;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([165, 72, 135, 225, 67, 181, 255, 135])
      ),
      0
    )
  ) {
    return VerifierRouterInstruction.AddVerifier;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([50, 32, 70, 130, 142, 41, 111, 175])
      ),
      0
    )
  ) {
    return VerifierRouterInstruction.CancelTransfer;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([179, 143, 200, 137, 108, 245, 248, 35])
      ),
      0
    )
  ) {
    return VerifierRouterInstruction.EmergencyStop;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([54, 84, 135, 9, 249, 7, 161, 4])
      ),
      0
    )
  ) {
    return VerifierRouterInstruction.EmergencyStopWithProof;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237])
      ),
      0
    )
  ) {
    return VerifierRouterInstruction.Initialize;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([19, 143, 91, 79, 34, 168, 174, 125])
      ),
      0
    )
  ) {
    return VerifierRouterInstruction.RenounceOwnership;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([65, 177, 215, 73, 53, 45, 99, 47])
      ),
      0
    )
  ) {
    return VerifierRouterInstruction.TransferOwnership;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([133, 161, 141, 48, 120, 198, 88, 150])
      ),
      0
    )
  ) {
    return VerifierRouterInstruction.Verify;
  }
  throw new Error(
    'The provided instruction could not be identified as a verifierRouter instruction.'
  );
}

export type ParsedVerifierRouterInstruction<
  TProgram extends string = '8U8NcScoHfKhbJCCUCM4ckmynCbhFM9Mo2xLVgrbosfh',
> =
  | ({
      instructionType: VerifierRouterInstruction.AcceptOwnership;
    } & ParsedAcceptOwnershipInstruction<TProgram>)
  | ({
      instructionType: VerifierRouterInstruction.AddVerifier;
    } & ParsedAddVerifierInstruction<TProgram>)
  | ({
      instructionType: VerifierRouterInstruction.CancelTransfer;
    } & ParsedCancelTransferInstruction<TProgram>)
  | ({
      instructionType: VerifierRouterInstruction.EmergencyStop;
    } & ParsedEmergencyStopInstruction<TProgram>)
  | ({
      instructionType: VerifierRouterInstruction.EmergencyStopWithProof;
    } & ParsedEmergencyStopWithProofInstruction<TProgram>)
  | ({
      instructionType: VerifierRouterInstruction.Initialize;
    } & ParsedInitializeInstruction<TProgram>)
  | ({
      instructionType: VerifierRouterInstruction.RenounceOwnership;
    } & ParsedRenounceOwnershipInstruction<TProgram>)
  | ({
      instructionType: VerifierRouterInstruction.TransferOwnership;
    } & ParsedTransferOwnershipInstruction<TProgram>)
  | ({
      instructionType: VerifierRouterInstruction.Verify;
    } & ParsedVerifyInstruction<TProgram>);
